// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{self as __sdk, __lib, __sats, __ws};

pub mod admin_type;
pub mod admins_table;
pub mod clear_all_identities_reducer;
pub mod clear_identity_reducer;
pub mod clock_type;
pub mod clocks_table;
pub mod entity_kind_type;
pub mod entity_state_type;
pub mod game_state_type;
pub mod game_type;
pub mod games_table;
pub mod identifiable_type;
pub mod identifiables_table;
pub mod identity_connected_reducer;
pub mod identity_disconnected_reducer;
pub mod impulse_all_balls_reducer;
pub mod impulse_reducer;
pub mod join_reducer;
pub mod kick_reducer;
pub mod message_type;
pub mod messages_table;
pub mod movable_type;
pub mod movables_table;
pub mod move_to_reducer;
pub mod ping_reducer;
pub mod pingable_type;
pub mod pingables_table;
pub mod remove_all_balls_reducer;
pub mod routable_type;
pub mod routables_table;
pub mod route_action_type;
pub mod say_reducer;
pub mod schedule_type;
pub mod schedules_table;
pub mod set_game_auto_start_reducer;
pub mod spawn_all_balls_reducer;
pub mod spawn_space_balls_reducer;
pub mod spawn_time_balls_reducer;
pub mod start_game_reducer;
pub mod start_infinite_game_reducer;
pub mod stat_type;
pub mod stats_table;
pub mod test_reducer;
pub mod throw_to_reducer;
pub mod update_reducer;
pub mod vector_3_d_type;

pub use admin_type::Admin;
pub use admins_table::*;
pub use clear_all_identities_reducer::{
    clear_all_identities, set_flags_for_clear_all_identities, ClearAllIdentitiesCallbackId,
};
pub use clear_identity_reducer::{
    clear_identity, set_flags_for_clear_identity, ClearIdentityCallbackId,
};
pub use clock_type::Clock;
pub use clocks_table::*;
pub use entity_kind_type::EntityKind;
pub use entity_state_type::EntityState;
pub use game_state_type::GameState;
pub use game_type::Game;
pub use games_table::*;
pub use identifiable_type::Identifiable;
pub use identifiables_table::*;
pub use identity_connected_reducer::{
    identity_connected, set_flags_for_identity_connected, IdentityConnectedCallbackId,
};
pub use identity_disconnected_reducer::{
    identity_disconnected, set_flags_for_identity_disconnected, IdentityDisconnectedCallbackId,
};
pub use impulse_all_balls_reducer::{
    impulse_all_balls, set_flags_for_impulse_all_balls, ImpulseAllBallsCallbackId,
};
pub use impulse_reducer::{impulse, set_flags_for_impulse, ImpulseCallbackId};
pub use join_reducer::{join, set_flags_for_join, JoinCallbackId};
pub use kick_reducer::{kick, set_flags_for_kick, KickCallbackId};
pub use message_type::Message;
pub use messages_table::*;
pub use movable_type::Movable;
pub use movables_table::*;
pub use move_to_reducer::{move_to, set_flags_for_move_to, MoveToCallbackId};
pub use ping_reducer::{ping, set_flags_for_ping, PingCallbackId};
pub use pingable_type::Pingable;
pub use pingables_table::*;
pub use remove_all_balls_reducer::{
    remove_all_balls, set_flags_for_remove_all_balls, RemoveAllBallsCallbackId,
};
pub use routable_type::Routable;
pub use routables_table::*;
pub use route_action_type::RouteAction;
pub use say_reducer::{say, set_flags_for_say, SayCallbackId};
pub use schedule_type::Schedule;
pub use schedules_table::*;
pub use set_game_auto_start_reducer::{
    set_flags_for_set_game_auto_start, set_game_auto_start, SetGameAutoStartCallbackId,
};
pub use spawn_all_balls_reducer::{
    set_flags_for_spawn_all_balls, spawn_all_balls, SpawnAllBallsCallbackId,
};
pub use spawn_space_balls_reducer::{
    set_flags_for_spawn_space_balls, spawn_space_balls, SpawnSpaceBallsCallbackId,
};
pub use spawn_time_balls_reducer::{
    set_flags_for_spawn_time_balls, spawn_time_balls, SpawnTimeBallsCallbackId,
};
pub use start_game_reducer::{set_flags_for_start_game, start_game, StartGameCallbackId};
pub use start_infinite_game_reducer::{
    set_flags_for_start_infinite_game, start_infinite_game, StartInfiniteGameCallbackId,
};
pub use stat_type::Stat;
pub use stats_table::*;
pub use test_reducer::{set_flags_for_test, test, TestCallbackId};
pub use throw_to_reducer::{set_flags_for_throw_to, throw_to, ThrowToCallbackId};
pub use update_reducer::{set_flags_for_update, update, UpdateCallbackId};
pub use vector_3_d_type::Vector3D;

#[derive(Clone, PartialEq, Debug)]

/// One of the reducers defined by this module.
///
/// Contained within a [`__sdk::ReducerEvent`] in [`EventContext`]s for reducer events
/// to indicate which reducer caused the event.

pub enum Reducer {
    ClearAllIdentities,
    ClearIdentity { name: String },
    IdentityConnected,
    IdentityDisconnected,
    Impulse { name: String, x: f32, y: f32 },
    ImpulseAllBalls,
    Join { name: String },
    Kick { name: String },
    MoveTo { x: f32, y: f32 },
    Ping { timestamp: i64 },
    RemoveAllBalls,
    Say { text: String },
    SetGameAutoStart { enable: bool },
    SpawnAllBalls { count: u8 },
    SpawnSpaceBalls { count: u8 },
    SpawnTimeBalls { count: u8 },
    StartGame { duration: u8 },
    StartInfiniteGame,
    Test { name: String },
    ThrowTo { x: f32, y: f32 },
    Update { arg: Schedule },
}

impl __sdk::InModule for Reducer {
    type Module = RemoteModule;
}

impl __sdk::Reducer for Reducer {
    fn reducer_name(&self) -> &'static str {
        match self {
            Reducer::ClearAllIdentities => "clear_all_identities",
            Reducer::ClearIdentity { .. } => "clear_identity",
            Reducer::IdentityConnected => "identity_connected",
            Reducer::IdentityDisconnected => "identity_disconnected",
            Reducer::Impulse { .. } => "impulse",
            Reducer::ImpulseAllBalls => "impulse_all_balls",
            Reducer::Join { .. } => "join",
            Reducer::Kick { .. } => "kick",
            Reducer::MoveTo { .. } => "move_to",
            Reducer::Ping { .. } => "ping",
            Reducer::RemoveAllBalls => "remove_all_balls",
            Reducer::Say { .. } => "say",
            Reducer::SetGameAutoStart { .. } => "set_game_auto_start",
            Reducer::SpawnAllBalls { .. } => "spawn_all_balls",
            Reducer::SpawnSpaceBalls { .. } => "spawn_space_balls",
            Reducer::SpawnTimeBalls { .. } => "spawn_time_balls",
            Reducer::StartGame { .. } => "start_game",
            Reducer::StartInfiniteGame => "start_infinite_game",
            Reducer::Test { .. } => "test",
            Reducer::ThrowTo { .. } => "throw_to",
            Reducer::Update { .. } => "update",
        }
    }
}
impl TryFrom<__ws::ReducerCallInfo<__ws::BsatnFormat>> for Reducer {
    type Error = __sdk::Error;
    fn try_from(value: __ws::ReducerCallInfo<__ws::BsatnFormat>) -> __sdk::Result<Self> {
        match &value.reducer_name[..] {
            "clear_all_identities" => Ok(__sdk::parse_reducer_args::<
                clear_all_identities_reducer::ClearAllIdentitiesArgs,
            >("clear_all_identities", &value.args)?
            .into()),
            "clear_identity" => Ok(__sdk::parse_reducer_args::<
                clear_identity_reducer::ClearIdentityArgs,
            >("clear_identity", &value.args)?
            .into()),
            "identity_connected" => Ok(__sdk::parse_reducer_args::<
                identity_connected_reducer::IdentityConnectedArgs,
            >("identity_connected", &value.args)?
            .into()),
            "identity_disconnected" => Ok(__sdk::parse_reducer_args::<
                identity_disconnected_reducer::IdentityDisconnectedArgs,
            >("identity_disconnected", &value.args)?
            .into()),
            "impulse" => Ok(__sdk::parse_reducer_args::<impulse_reducer::ImpulseArgs>(
                "impulse",
                &value.args,
            )?
            .into()),
            "impulse_all_balls" => Ok(__sdk::parse_reducer_args::<
                impulse_all_balls_reducer::ImpulseAllBallsArgs,
            >("impulse_all_balls", &value.args)?
            .into()),
            "join" => Ok(
                __sdk::parse_reducer_args::<join_reducer::JoinArgs>("join", &value.args)?.into(),
            ),
            "kick" => Ok(
                __sdk::parse_reducer_args::<kick_reducer::KickArgs>("kick", &value.args)?.into(),
            ),
            "move_to" => Ok(__sdk::parse_reducer_args::<move_to_reducer::MoveToArgs>(
                "move_to",
                &value.args,
            )?
            .into()),
            "ping" => Ok(
                __sdk::parse_reducer_args::<ping_reducer::PingArgs>("ping", &value.args)?.into(),
            ),
            "remove_all_balls" => Ok(__sdk::parse_reducer_args::<
                remove_all_balls_reducer::RemoveAllBallsArgs,
            >("remove_all_balls", &value.args)?
            .into()),
            "say" => {
                Ok(__sdk::parse_reducer_args::<say_reducer::SayArgs>("say", &value.args)?.into())
            }
            "set_game_auto_start" => Ok(__sdk::parse_reducer_args::<
                set_game_auto_start_reducer::SetGameAutoStartArgs,
            >("set_game_auto_start", &value.args)?
            .into()),
            "spawn_all_balls" => Ok(__sdk::parse_reducer_args::<
                spawn_all_balls_reducer::SpawnAllBallsArgs,
            >("spawn_all_balls", &value.args)?
            .into()),
            "spawn_space_balls" => Ok(__sdk::parse_reducer_args::<
                spawn_space_balls_reducer::SpawnSpaceBallsArgs,
            >("spawn_space_balls", &value.args)?
            .into()),
            "spawn_time_balls" => Ok(__sdk::parse_reducer_args::<
                spawn_time_balls_reducer::SpawnTimeBallsArgs,
            >("spawn_time_balls", &value.args)?
            .into()),
            "start_game" => Ok(
                __sdk::parse_reducer_args::<start_game_reducer::StartGameArgs>(
                    "start_game",
                    &value.args,
                )?
                .into(),
            ),
            "start_infinite_game" => Ok(__sdk::parse_reducer_args::<
                start_infinite_game_reducer::StartInfiniteGameArgs,
            >("start_infinite_game", &value.args)?
            .into()),
            "test" => Ok(
                __sdk::parse_reducer_args::<test_reducer::TestArgs>("test", &value.args)?.into(),
            ),
            "throw_to" => Ok(__sdk::parse_reducer_args::<throw_to_reducer::ThrowToArgs>(
                "throw_to",
                &value.args,
            )?
            .into()),
            "update" => Ok(__sdk::parse_reducer_args::<update_reducer::UpdateArgs>(
                "update",
                &value.args,
            )?
            .into()),
            unknown => {
                Err(
                    __sdk::InternalError::unknown_name("reducer", unknown, "ReducerCallInfo")
                        .into(),
                )
            }
        }
    }
}

#[derive(Default)]
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct DbUpdate {
    admins: __sdk::TableUpdate<Admin>,
    clocks: __sdk::TableUpdate<Clock>,
    games: __sdk::TableUpdate<Game>,
    identifiables: __sdk::TableUpdate<Identifiable>,
    messages: __sdk::TableUpdate<Message>,
    movables: __sdk::TableUpdate<Movable>,
    pingables: __sdk::TableUpdate<Pingable>,
    routables: __sdk::TableUpdate<Routable>,
    schedules: __sdk::TableUpdate<Schedule>,
    stats: __sdk::TableUpdate<Stat>,
}

impl TryFrom<__ws::DatabaseUpdate<__ws::BsatnFormat>> for DbUpdate {
    type Error = __sdk::Error;
    fn try_from(raw: __ws::DatabaseUpdate<__ws::BsatnFormat>) -> Result<Self, Self::Error> {
        let mut db_update = DbUpdate::default();
        for table_update in raw.tables {
            match &table_update.table_name[..] {
                "admins" => db_update.admins = admins_table::parse_table_update(table_update)?,
                "clocks" => db_update.clocks = clocks_table::parse_table_update(table_update)?,
                "games" => db_update.games = games_table::parse_table_update(table_update)?,
                "identifiables" => {
                    db_update.identifiables = identifiables_table::parse_table_update(table_update)?
                }
                "messages" => {
                    db_update.messages = messages_table::parse_table_update(table_update)?
                }
                "movables" => {
                    db_update.movables = movables_table::parse_table_update(table_update)?
                }
                "pingables" => {
                    db_update.pingables = pingables_table::parse_table_update(table_update)?
                }
                "routables" => {
                    db_update.routables = routables_table::parse_table_update(table_update)?
                }
                "schedules" => {
                    db_update.schedules = schedules_table::parse_table_update(table_update)?
                }
                "stats" => db_update.stats = stats_table::parse_table_update(table_update)?,

                unknown => {
                    return Err(__sdk::InternalError::unknown_name(
                        "table",
                        unknown,
                        "DatabaseUpdate",
                    )
                    .into());
                }
            }
        }
        Ok(db_update)
    }
}

impl __sdk::InModule for DbUpdate {
    type Module = RemoteModule;
}

impl __sdk::DbUpdate for DbUpdate {
    fn apply_to_client_cache(
        &self,
        cache: &mut __sdk::ClientCache<RemoteModule>,
    ) -> AppliedDiff<'_> {
        let mut diff = AppliedDiff::default();

        diff.admins = cache
            .apply_diff_to_table::<Admin>("admins", &self.admins)
            .with_updates_by_pk(|row| &row.identity);
        diff.clocks = cache
            .apply_diff_to_table::<Clock>("clocks", &self.clocks)
            .with_updates_by_pk(|row| &row.id);
        diff.games = cache
            .apply_diff_to_table::<Game>("games", &self.games)
            .with_updates_by_pk(|row| &row.id);
        diff.identifiables = cache
            .apply_diff_to_table::<Identifiable>("identifiables", &self.identifiables)
            .with_updates_by_pk(|row| &row.name);
        diff.messages = cache
            .apply_diff_to_table::<Message>("messages", &self.messages)
            .with_updates_by_pk(|row| &row.name);
        diff.movables = cache
            .apply_diff_to_table::<Movable>("movables", &self.movables)
            .with_updates_by_pk(|row| &row.name);
        diff.pingables = cache
            .apply_diff_to_table::<Pingable>("pingables", &self.pingables)
            .with_updates_by_pk(|row| &row.name);
        diff.routables = cache
            .apply_diff_to_table::<Routable>("routables", &self.routables)
            .with_updates_by_pk(|row| &row.name);
        diff.schedules = cache
            .apply_diff_to_table::<Schedule>("schedules", &self.schedules)
            .with_updates_by_pk(|row| &row.scheduled_id);
        diff.stats = cache
            .apply_diff_to_table::<Stat>("stats", &self.stats)
            .with_updates_by_pk(|row| &row.name);

        diff
    }
}

#[derive(Default)]
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct AppliedDiff<'r> {
    admins: __sdk::TableAppliedDiff<'r, Admin>,
    clocks: __sdk::TableAppliedDiff<'r, Clock>,
    games: __sdk::TableAppliedDiff<'r, Game>,
    identifiables: __sdk::TableAppliedDiff<'r, Identifiable>,
    messages: __sdk::TableAppliedDiff<'r, Message>,
    movables: __sdk::TableAppliedDiff<'r, Movable>,
    pingables: __sdk::TableAppliedDiff<'r, Pingable>,
    routables: __sdk::TableAppliedDiff<'r, Routable>,
    schedules: __sdk::TableAppliedDiff<'r, Schedule>,
    stats: __sdk::TableAppliedDiff<'r, Stat>,
}

impl __sdk::InModule for AppliedDiff<'_> {
    type Module = RemoteModule;
}

impl<'r> __sdk::AppliedDiff<'r> for AppliedDiff<'r> {
    fn invoke_row_callbacks(
        &self,
        event: &EventContext,
        callbacks: &mut __sdk::DbCallbacks<RemoteModule>,
    ) {
        callbacks.invoke_table_row_callbacks::<Admin>("admins", &self.admins, event);
        callbacks.invoke_table_row_callbacks::<Clock>("clocks", &self.clocks, event);
        callbacks.invoke_table_row_callbacks::<Game>("games", &self.games, event);
        callbacks.invoke_table_row_callbacks::<Identifiable>(
            "identifiables",
            &self.identifiables,
            event,
        );
        callbacks.invoke_table_row_callbacks::<Message>("messages", &self.messages, event);
        callbacks.invoke_table_row_callbacks::<Movable>("movables", &self.movables, event);
        callbacks.invoke_table_row_callbacks::<Pingable>("pingables", &self.pingables, event);
        callbacks.invoke_table_row_callbacks::<Routable>("routables", &self.routables, event);
        callbacks.invoke_table_row_callbacks::<Schedule>("schedules", &self.schedules, event);
        callbacks.invoke_table_row_callbacks::<Stat>("stats", &self.stats, event);
    }
}

#[doc(hidden)]
pub struct RemoteModule;

impl __sdk::InModule for RemoteModule {
    type Module = Self;
}

/// The `reducers` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each reducer defined by the module.
pub struct RemoteReducers {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteReducers {
    type Module = RemoteModule;
}

#[doc(hidden)]
/// The `set_reducer_flags` field of [`DbConnection`],
/// with methods provided by extension traits for each reducer defined by the module.
/// Each method sets the flags for the reducer with the same name.
///
/// This type is currently unstable and may be removed without a major version bump.
pub struct SetReducerFlags {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for SetReducerFlags {
    type Module = RemoteModule;
}

/// The `db` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each table defined by the module.
pub struct RemoteTables {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteTables {
    type Module = RemoteModule;
}

/// A connection to a remote module, including a materialized view of a subset of the database.
///
/// Connect to a remote module by calling [`DbConnection::builder`]
/// and using the [`__sdk::DbConnectionBuilder`] builder-pattern constructor.
///
/// You must explicitly advance the connection by calling any one of:
///
/// - [`DbConnection::frame_tick`].
/// - [`DbConnection::run_threaded`].
/// - [`DbConnection::run_async`].
/// - [`DbConnection::advance_one_message`].
/// - [`DbConnection::advance_one_message_blocking`].
/// - [`DbConnection::advance_one_message_async`].
///
/// Which of these methods you should call depends on the specific needs of your application,
/// but you must call one of them, or else the connection will never progress.
pub struct DbConnection {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    #[doc(hidden)]
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,

    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for DbConnection {
    type Module = RemoteModule;
}

impl __sdk::DbContext for DbConnection {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
}

impl DbConnection {
    /// Builder-pattern constructor for a connection to a remote module.
    ///
    /// See [`__sdk::DbConnectionBuilder`] for required and optional configuration for the new connection.
    pub fn builder() -> __sdk::DbConnectionBuilder<RemoteModule> {
        __sdk::DbConnectionBuilder::new()
    }

    /// If any WebSocket messages are waiting, process one of them.
    ///
    /// Returns `true` if a message was processed, or `false` if the queue is empty.
    /// Callers should invoke this message in a loop until it returns `false`
    /// or for as much time is available to process messages.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::frame_tick`] each frame
    /// to fully exhaust the queue whenever time is available.
    pub fn advance_one_message(&self) -> __sdk::Result<bool> {
        self.imp.advance_one_message()
    }

    /// Process one WebSocket message, potentially blocking the current thread until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_threaded`] to spawn a thread
    /// which advances the connection automatically.
    pub fn advance_one_message_blocking(&self) -> __sdk::Result<()> {
        self.imp.advance_one_message_blocking()
    }

    /// Process one WebSocket message, `await`ing until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_async`] to run an `async` loop
    /// which advances the connection when polled.
    pub async fn advance_one_message_async(&self) -> __sdk::Result<()> {
        self.imp.advance_one_message_async().await
    }

    /// Process all WebSocket messages waiting in the queue,
    /// then return without `await`ing or blocking the current thread.
    pub fn frame_tick(&self) -> __sdk::Result<()> {
        self.imp.frame_tick()
    }

    /// Spawn a thread which processes WebSocket messages as they are received.
    pub fn run_threaded(&self) -> std::thread::JoinHandle<()> {
        self.imp.run_threaded()
    }

    /// Run an `async` loop which processes WebSocket messages when polled.
    pub async fn run_async(&self) -> __sdk::Result<()> {
        self.imp.run_async().await
    }
}

impl __sdk::DbConnection for DbConnection {
    fn new(imp: __sdk::DbContextImpl<RemoteModule>) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            imp,
        }
    }
}

/// A handle on a subscribed query.
// TODO: Document this better after implementing the new subscription API.
#[derive(Clone)]
pub struct SubscriptionHandle {
    imp: __sdk::SubscriptionHandleImpl<RemoteModule>,
}

impl __sdk::InModule for SubscriptionHandle {
    type Module = RemoteModule;
}

impl __sdk::SubscriptionHandle for SubscriptionHandle {
    fn new(imp: __sdk::SubscriptionHandleImpl<RemoteModule>) -> Self {
        Self { imp }
    }

    /// Returns true if this subscription has been terminated due to an unsubscribe call or an error.
    fn is_ended(&self) -> bool {
        self.imp.is_ended()
    }

    /// Returns true if this subscription has been applied and has not yet been unsubscribed.
    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    /// Unsubscribe from the query controlled by this `SubscriptionHandle`,
    /// then run `on_end` when its rows are removed from the client cache.
    fn unsubscribe_then(self, on_end: __sdk::OnEndedCallback<RemoteModule>) -> __sdk::Result<()> {
        self.imp.unsubscribe_then(Some(on_end))
    }

    fn unsubscribe(self) -> __sdk::Result<()> {
        self.imp.unsubscribe_then(None)
    }
}

/// Alias trait for a [`__sdk::DbContext`] connected to this module,
/// with that trait's associated types bounded to this module's concrete types.
///
/// Users can use this trait as a boundary on definitions which should accept
/// either a [`DbConnection`] or an [`EventContext`] and operate on either.
pub trait RemoteDbContext:
    __sdk::DbContext<
    DbView = RemoteTables,
    Reducers = RemoteReducers,
    SetReducerFlags = SetReducerFlags,
    SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>,
>
{
}
impl<
        Ctx: __sdk::DbContext<
            DbView = RemoteTables,
            Reducers = RemoteReducers,
            SetReducerFlags = SetReducerFlags,
            SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>,
        >,
    > RemoteDbContext for Ctx
{
}

/// An [`__sdk::DbContext`] augmented with a [`__sdk::Event`],
/// passed to [`__sdk::Table::on_insert`], [`__sdk::Table::on_delete`] and [`__sdk::TableWithPrimaryKey::on_update`] callbacks.
pub struct EventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    /// The event which caused these callbacks to run.
    pub event: __sdk::Event<Reducer>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for EventContext {
    type Event = __sdk::Event<Reducer>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for EventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for EventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
}

impl __sdk::EventContext for EventContext {}

/// An [`__sdk::DbContext`] augmented with a [`__sdk::ReducerEvent`],
/// passed to on-reducer callbacks.
pub struct ReducerEventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    /// The event which caused these callbacks to run.
    pub event: __sdk::ReducerEvent<Reducer>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for ReducerEventContext {
    type Event = __sdk::ReducerEvent<Reducer>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for ReducerEventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for ReducerEventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
}

impl __sdk::ReducerEventContext for ReducerEventContext {}

/// An [`__sdk::DbContext`] passed to [`__sdk::SubscriptionBuilder::on_applied`] and [`SubscriptionHandle::unsubscribe_then`] callbacks.
pub struct SubscriptionEventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for SubscriptionEventContext {
    type Event = ();
    fn event(&self) -> &Self::Event {
        &()
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, _event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            imp,
        }
    }
}

impl __sdk::InModule for SubscriptionEventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for SubscriptionEventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
}

impl __sdk::SubscriptionEventContext for SubscriptionEventContext {}

/// An [`__sdk::DbContext`] augmented with a [`__sdk::Error`],
/// passed to [`__sdk::DbConnectionBuilder::on_disconnect`], [`__sdk::DbConnectionBuilder::on_connect_error`] and [`__sdk::SubscriptionBuilder::on_error`] callbacks.
pub struct ErrorContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    /// The event which caused these callbacks to run.
    pub event: Option<__sdk::Error>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for ErrorContext {
    type Event = Option<__sdk::Error>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for ErrorContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for ErrorContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
}

impl __sdk::ErrorContext for ErrorContext {}

impl __sdk::SpacetimeModule for RemoteModule {
    type DbConnection = DbConnection;
    type EventContext = EventContext;
    type ReducerEventContext = ReducerEventContext;
    type SubscriptionEventContext = SubscriptionEventContext;
    type ErrorContext = ErrorContext;
    type Reducer = Reducer;
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;
    type DbUpdate = DbUpdate;
    type AppliedDiff<'r> = AppliedDiff<'r>;
    type SubscriptionHandle = SubscriptionHandle;

    fn register_tables(client_cache: &mut __sdk::ClientCache<Self>) {
        admins_table::register_table(client_cache);
        clocks_table::register_table(client_cache);
        games_table::register_table(client_cache);
        identifiables_table::register_table(client_cache);
        messages_table::register_table(client_cache);
        movables_table::register_table(client_cache);
        pingables_table::register_table(client_cache);
        routables_table::register_table(client_cache);
        schedules_table::register_table(client_cache);
        stats_table::register_table(client_cache);
    }
}
